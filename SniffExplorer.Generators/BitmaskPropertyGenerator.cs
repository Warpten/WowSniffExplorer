using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using Scriban;
using SniffExplorer.Generators.UpdateFields;
using SniffExplorer.Generators.Utilities;
using SniffExplorer.Shared.Attributes.UI;

namespace SniffExplorer.Generators
{
    [Generator]
    public class BitmaskPropertyGenerator : ISourceGenerator
    {
        private static readonly string ATTRIBUTE_NAME = typeof(EnumFlagPropertyAttribute).FullName;

        private static readonly Template _template;

        static BitmaskPropertyGenerator()
        {
            _template = Template.Parse(@"// AUTOGENERATED FILE - DO NOT EDIT
// This file was generated by {{ GeneratorName }} on {{ GenerationDate }}.
using System;
using System.Collections.Generic;
using System.ComponentModel;

namespace {{ ContainingNamespace }}
{
    public partial class {{ EnhancedTypeName }} : {{ NotifySymbolName }}
    {
        {{ for property in Properties }}
        public bool {{ property.PropertyName }}
        {
            get => {{ property.BackingMember }}.HasFlag({{ property.Enumeration }}.{{ property.PropertyName }});
            set {
                if ({{ property.BackingMember }}.HasFlag({{ property.Enumeration }}.{{ property.PropertyName }}) == value)
                    return;

                if (value)
                    {{ property.BackingMember }} |= {{ property.Enumeration }}.{{ property.PropertyName }};
                else
                    {{ property.BackingMember }} &= ~{{ property.Enumeration }}.{{ property.PropertyName }};

                PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof({{ property.PropertyName }})));
            }
        }
        {{ end }}

        {{ if NotifyEventHandler }}
        public event {{ NotifyEventHandler }} PropertyChanged;
        {{ end }}
    }
}
");
        }

        public void Initialize(GeneratorInitializationContext context)
        {
            // Register a syntax receiver that will be created for each generation pass
            context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            // retrieve the populated receiver 
            if (!(context.SyntaxContextReceiver is SyntaxReceiver receiver))
                return;

            // get the added attribute, and INotifyPropertyChanged
            var notifySymbol = context.GetSymbol<INotifyPropertyChanged>();

            // group the fields by class, and generate the source
            var fieldGroups = receiver.Fields.GroupBy(f => f.ContainingType, e => e, SymbolEqualityComparer.Default).ToDictionary(g => g.Key, g => g.ToList());
            var propertyGroups = receiver.Properties.GroupBy(f => f.ContainingType, e => e, SymbolEqualityComparer.Default).ToDictionary(g => g.Key, g => g.ToList());

            foreach (var containingType in fieldGroups.Select(f => f.Key)
                .Union(propertyGroups.Select(p => p.Key), SymbolEqualityComparer.Default).Cast<INamedTypeSymbol>())
            {
                var npcImplemented = containingType.Interfaces.Contains(notifySymbol, SymbolEqualityComparer.Default);
                var npcEventHandler = context.GetSymbol<PropertyChangedEventHandler>();

                if (!fieldGroups.TryGetValue(containingType, out var fields))
                    fields = new List<IFieldSymbol>();

                if (!propertyGroups.TryGetValue(containingType, out var properties))
                    properties = new List<IPropertySymbol>();

                var members = fields.Union(properties, SymbolEqualityComparer.Default);

                var file = _template.Render(new
                {
                    GeneratorName = nameof(BitmaskPropertyGenerator),
                    GenerationDate = DateTime.Now.ToString(),
                    EnhancedTypeName = containingType.Name,
                    NotifySymbolName = notifySymbol!.ToDisplayString(),
                    NotifyEventHandler = npcImplemented ? null : npcEventHandler?.ToDisplayString(),
                    ContainingNamespace = containingType.ContainingNamespace.ToDisplayString(),
                    Properties = members.SelectMany(field =>
                    {
                        if (field == null)
                            return null;

                        var fieldType = field switch {
                            IPropertySymbol propertySymbol => propertySymbol.Type,
                            IFieldSymbol fieldSymbol       => fieldSymbol.Type,
                            _                              => null
                        };

                        if (fieldType == null)
                            return null;

                        var attributeSymbol = context.Compilation.GetTypeByMetadataName(typeof(FlagsAttribute).FullName);
                        var attributeData = fieldType.FindAttribute(attributeSymbol);
                        if (attributeData == null)
                            return null;

                        var fieldTypeEnumerations = fieldType.GetMembers().OfType<IFieldSymbol>();
                        return fieldTypeEnumerations.Select(fieldEnumeration =>
                        {
                            return new
                            {
                                BackingMember = field.Name,
                                PropertyName = fieldEnumeration.Name,
                                Enumeration = fieldEnumeration.Type.ToDisplayString()
                            };
                        });
                    }).Where(i => i != null)
                }, memberInfo => memberInfo.Name);

                context.AddSource($"{containingType!.Name}.Generated.cs", SourceText.From(file, Encoding.UTF8));
            }
        }

        class SyntaxReceiver : ISyntaxContextReceiver
        {
            public List<IFieldSymbol> Fields { get; } = new();
            public List<IPropertySymbol> Properties { get; } = new();

            /// <summary>
            /// Called for every syntax node in the compilation, we can inspect the nodes and save any information useful for generation
            /// </summary>
            public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
            {
                // any field with at least one attribute is a candidate for property generation
                if (context.Node is FieldDeclarationSyntax fieldDeclarationSyntax && fieldDeclarationSyntax.AttributeLists.Count > 0)
                {
                    foreach (var variable in fieldDeclarationSyntax.Declaration.Variables)
                    {
                        // Get the symbol being declared by the field, and keep it if its annotated
                        var fieldSymbol = context.SemanticModel.GetDeclaredSymbol(variable) as IFieldSymbol;
                        if (fieldSymbol == null)
                            continue;

                        // Not an enum, skip
                        if (fieldSymbol.Type.TypeKind != TypeKind.Enum)
                            continue;

                        var fieldAttributes = fieldSymbol!.GetAttributes();

                        // Is marked for generation
                        if (fieldAttributes.Any(ad => ad.AttributeClass!.ToDisplayString() == ATTRIBUTE_NAME))
                            Fields.Add(fieldSymbol);
                    }
                }

                if (context.Node is PropertyDeclarationSyntax propertyDeclarationSyntax && propertyDeclarationSyntax.AttributeLists.Count > 0)
                {
                    var propertySymbol = context.SemanticModel.GetDeclaredSymbol(propertyDeclarationSyntax);
                    if (propertySymbol == null)
                        return;

                    var propertyAttributes = propertySymbol.GetAttributes();

                    // Is marked for generation
                    if (propertyAttributes.Any(ad => ad.AttributeClass!.ToDisplayString() == ATTRIBUTE_NAME))
                        Properties.Add(propertySymbol);
                }
            }
        }
    }
}
