using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using Scriban;
using SniffExplorer.Generators.Utilities;
using SniffExplorer.Shared.Attributes.UI;

namespace SniffExplorer.Generators
{
    [Generator]
    public class NotifyingPropertyGenerator : ISourceGenerator
    {
        private static readonly string ATTRIBUTE_NAME = typeof(NotifyingPropertyAttribute).FullName;

        private static readonly Template _template;

        static NotifyingPropertyGenerator()
        {
            _template = Template.Parse(@"// AUTOGENERATED FILE - DO NOT EDIT
// This file was generated by {{ GeneratorName }} on {{ GenerationDate }}.
using System;
using System.Collections.Generic;
using System.ComponentModel;

namespace {{ ContainingNamespace }}
{
    public partial class {{ EnhancedTypeName }} : {{ if BaseType }}{{ BaseType }}, {{ end }}{{ NotifySymbolName }}
    {
        {{ for property in Properties }}
        public {{ property.Type }} {{ property.PropertyName }}
        {
            get => {{ property.FieldName }};
            set {
                if (EqualityComparer<{{ property.Type }}>.Default.Equals({{ property.FieldName }}, value))
                    return;

                Before{{ property.PropertyName }}Change({{ property.FieldName }}, value);
                {{ property.FieldName }} = value;
                After{{ property.PropertyName }}Change();
                NotifyPropertyChanged(nameof({{ property.PropertyName }}));
            }
        }

        partial void Before{{ property.PropertyName }}Change({{ property.Type }} oldValue, {{ property.Type }} newValue);
        partial void After{{ property.PropertyName }}Change();
        {{ end }}

        {{ if NotifyEventHandler }}
        public event {{ NotifyEventHandler }} PropertyChanged;
        {{ end }}

        {{ if GenerateNotifier }}
        protected void NotifyPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
        {{ end }}
    }
}
");
        }

        public void Execute(GeneratorExecutionContext context)
        {
            // retrieve the populated receiver 
            if (!(context.SyntaxContextReceiver is SyntaxReceiver receiver))
                return;

            // get the added attribute, and INotifyPropertyChanged
            var notifySymbol = context.GetSymbol<INotifyPropertyChanged>();

            // group the fields by class, and generate the source
            foreach (var group in receiver.Fields.GroupBy(f => f.ContainingType, e => e, SymbolEqualityComparer.Default))
            {
                var classSymbol = (INamedTypeSymbol) group.Key!;
                
                var npcImplemented = classSymbol.AllInterfaces.Contains(notifySymbol, SymbolEqualityComparer.Default);
                var npcEventHandler = context.GetSymbol<PropertyChangedEventHandler>();

                string? chooseName(string fieldName, TypedConstant? overridenNameOpt)
                {
                    if (overridenNameOpt.HasValue && overridenNameOpt.Value.IsNull)
                        return overridenNameOpt.Value.Value!.ToString();

                    fieldName = fieldName.TrimStart('_');
                    if (fieldName.Length == 0)
                        return string.Empty;

                    if (fieldName.Length == 1)
                        return fieldName.ToUpper();

                    return fieldName.Substring(0, 1).ToUpper() + fieldName.Substring(1);
                }

                var file = _template.Render(new
                {
                    GeneratorName = nameof(NotifyingPropertyGenerator),
                    GenerationDate = DateTime.Now.ToString(),
                    EnhancedTypeName = group.Key!.ToDisplayString().Split('.').Last(),
                    BaseType = classSymbol.BaseType,
                    GenerateNotifier = !classSymbol.BaseType?.AllInterfaces.Contains(notifySymbol!) ?? true,
                    NotifySymbolName = notifySymbol!.ToDisplayString(),
                    NotifyEventHandler = npcImplemented ? null : npcEventHandler?.ToDisplayString(),
                    ContainingNamespace = classSymbol.ContainingNamespace.ToDisplayString(),
                    Properties = group.Select(field =>
                    {
                        var attributeData = field.FindAttribute<NotifyingPropertyAttribute>(context);
                        var overridenNameOpt = attributeData?.NamedArguments.SingleOrDefault(kvp => kvp.Key == "PropertyName").Value;

                        return new
                        {
                            Type = field.Type.ToDisplayString(),
                            FieldName = field.Name,
                            PropertyName = chooseName(field.Name, overridenNameOpt)
                        };
                    })
                }, memberInfo => memberInfo.Name);

                context.AddSource($"{group.Key!.Name}.Generated.cs", SourceText.From(file, Encoding.UTF8));
            }
        }

        public void Initialize(GeneratorInitializationContext context)
        {
            // if (!Debugger.IsAttached)
            //     Debugger.Launch();

            // Register a syntax receiver that will be created for each generation pass
            context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
        }

        class SyntaxReceiver : ISyntaxContextReceiver
        {
            public List<IFieldSymbol> Fields { get; } = new();

            /// <summary>
            /// Called for every syntax node in the compilation, we can inspect the nodes and save any information useful for generation
            /// </summary>
            public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
            {
                // any field with at least one attribute is a candidate for property generation
                if (context.Node is FieldDeclarationSyntax fieldDeclarationSyntax
                    && fieldDeclarationSyntax.AttributeLists.Count > 0)
                {
                    foreach (VariableDeclaratorSyntax variable in fieldDeclarationSyntax.Declaration.Variables)
                    {
                        // Get the symbol being declared by the field, and keep it if its annotated
                        var fieldSymbol = context.SemanticModel.GetDeclaredSymbol(variable) as IFieldSymbol;
                        if (fieldSymbol!.GetAttributes().Any(ad => ad.AttributeClass!.ToDisplayString() == ATTRIBUTE_NAME))
                            Fields.Add(fieldSymbol);
                    }
                }
            }
        }
    }
}
